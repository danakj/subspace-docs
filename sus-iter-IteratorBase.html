<head>
  <title>
    sus::iter::IteratorBase
  </title>
  <link rel="stylesheet" href="subdoc-test-style.css">
</head>

<body>
  <div class="type record class">
    <div class="section overview">
      <div class="section-header">
        <span>
          Class
        </span>
        <span><a>sus</a>::<a>iter</a>::<a class="type-name" href="#">IteratorBase</a></span>
      </div>
      <div class="type-signature">
        <span class="class">
          class
        </span>
        <span class="type-name">
          IteratorBase
        </span>
        <div class="record-body">
          { ... };
        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Methods
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.all" href="#method.all">all</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (Item)&gt;">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.all" href="#method.all">all</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (Item)&gt;">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.all" href="#method.all">all</a>
          <span class="function-params">(<a class="type-name" title="class ::sus::fn::FnMut&lt;_Bool (Item)&gt;" href="sus-fn-FnMut.html">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="description">
          <p>Tests whether all elements of the iterator match a predicate.</p><p>If the predicate returns <code>true</code> for all elements in the iterator, this functions returns <code>true</code>, otherwise <code>false</code>. The function is short-circuiting; it stops iterating on the first <code>false</code> returned from the predicate.</p><p>Returns <code>true</code> if the iterator is empty.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.any" href="#method.any">any</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (Item)&gt;">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.any" href="#method.any">any</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (Item)&gt;">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.any" href="#method.any">any</a>
          <span class="function-params">(<a class="type-name" title="class ::sus::fn::FnMut&lt;_Bool (Item)&gt;" href="sus-fn-FnMut.html">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="description">
          <p>Tests whether any elements of the iterator match a predicate.</p><p>If the predicate returns <code>true</code> for any elements in the iterator, this functions returns <code>true</code>, otherwise <code>false</code>. The function is short-circuiting; it stops iterating on the first <code>true</code> returned from the predicate.</p><p>Returns <code>false</code> if the iterator is empty.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="const Iter &">const Iter &</a>
          <a class="function-name" name="method.as_subclass" href="#method.as_subclass">as_subclass</a>
          <span class="function-params">()</span>
          <span class="const">
            const
          </span>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="Iter &">Iter &</a>
          <a class="function-name" name="method.as_subclass_mut" href="#method.as_subclass_mut">as_subclass_mut</a>
          <span class="function-params">()</span>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.begin" href="#method.begin">begin</a>
          <span class="function-params">()</span>
          <span class="mutable ref">
            &
          </span>
        </div>
        <div class="description">
          <p>Adaptor for use in ranged for loops.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.box" href="#method.box">box</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.box" href="#method.box">box</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Wraps the iterator in a new iterator that is trivially relocatable.</p><p>Being trivially relocatable is required to chain the iterator, though methods such as <code>filter()</code>. This method converts the iterator to be trivially relocatable by moving the iterator into heap storage, which implies this does a heap allocation, which is slow compared to working on the stack.</p><p>When possible, favour making the iterator be trivially relocatable by having it iterate over types which are themselves trivially relocatable, instead of using <code>box()</code>. This will give much better performance.</p><p>It's only possible to call this in cases where it would do something useful, that is when the Iterator type is not trivially relocatable.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="FromIterator&lt;ItemT&gt; auto">FromIterator&lt;ItemT&gt; auto</a>
          <a class="function-name" name="method.collect" href="#method.collect">collect</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="FromIterator&lt;ItemT&gt; auto">FromIterator&lt;ItemT&gt; auto</a>
          <a class="function-name" name="method.collect" href="#method.collect">collect</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Transforms an iterator into a collection.</p><p>collect() can turn anything iterable into a relevant collection. If this is used anything like in Rust, it would be one of the more powerful methods in the subspace library, used in a variety of contexts.</p><p>The most basic pattern in which collect() is used is to turn one collection into another. You take a collection, call iter on it, do a bunch of transformations, and then collect() at the end.</p><p>collect() can also create instances of types that are not typical collections. For example, (TODO: a String can be built from chars, and) an iterator of Result&lt;T, E&gt; items can be collected into Result&lt;Collection&lt;T&gt;, E&gt;. Or an iterator of Option&lt;T&gt; can be collected into Option&lt;Collection&lt;T&gt;&gt;.</p><p>Because collect() is so general, and C++ lacks strong type inference, collect() doesn't know the type of collection that you want to produce, so you will always need to pass it a type argument, such as:</p><pre><code>sus::move(iter).collect&lt;MyContainer&lt;i32&gt;&gt;()
</code></pre><p></p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="::sus::containers::Vec&lt;ItemT&gt;">Vec&lt;ItemT&gt;</a>
          <a class="function-name" name="method.collect_vec" href="#method.collect_vec">collect_vec</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="::sus::containers::Vec&lt;ItemT&gt;">Vec&lt;ItemT&gt;</a>
          <a class="function-name" name="method.collect_vec" href="#method.collect_vec">collect_vec</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Transforms an iterator into a Vec.</p><p>This function is a shorthand for <code>it.collect&lt;Vec&lt;Item&gt;&gt;()</code> in order to avoid the need for specifying a template argument.</p><p>See <code>collect()</code> for more details.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="struct ::sus::num::usize" href="sus-num-usize.html">usize</a>
          <a class="function-name" name="method.count" href="#method.count">count</a>
          <span class="function-params">()</span>
        </div>
        <div class="overload">
          <a class="type-name" title="struct ::sus::num::usize" href="sus-num-usize.html">usize</a>
          <a class="function-name" name="method.count" href="#method.count">count</a>
          <span class="function-params">()</span>
        </div>
        <div class="overload">
          <a class="type-name" title="struct ::sus::num::usize" href="sus-num-usize.html">usize</a>
          <a class="function-name" name="method.count" href="#method.count">count</a>
          <span class="function-params">()</span>
        </div>
        <div class="description">
          <p>Consumes the iterator, and returns the number of elements that were in it.</p><p>The function walks the iterator until it sees an Option holding #None.</p><p></p><h1>Safety</h1><p></p><p>If the <code>usize</code> type does not have trapping arithmetic enabled, and the iterator has more than <code>usize::MAX</code> elements in it, the value will wrap and be incorrect. Otherwise, <code>usize</code> will catch overflow and panic.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.end" href="#method.end">end</a>
          <span class="function-params">()</span>
          <span class="mutable ref">
            &
          </span>
        </div>
        <div class="description">
          <p>Adaptor for use in ranged for loops.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.filter" href="#method.filter">filter</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (const std::remove_reference_t&lt;Item&gt; &)&gt;">FnMut&lt;_Bool (const std::remove_reference_t&lt;Item&gt; &)&gt;</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.filter" href="#method.filter">filter</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (const std::remove_reference_t&lt;Item&gt; &)&gt;">FnMut&lt;_Bool (const std::remove_reference_t&lt;Item&gt; &)&gt;</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Creates an iterator which uses a closure to determine if an element should be yielded.</p><p>Given an element the closure must return true or false. The returned iterator will yield only the elements for which the closure returns true.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="Iter &&">Iter &&</a>
          <a class="function-name" name="method.into_iter" href="#method.into_iter">into_iter</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>An Iterator also satisfies IntoIterator, which simply returns itself.</p><p>sus::iter::IntoIterator trait implementation.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.map" href="#method.map">map</a>
          <span class="function-params">(<a class="type-name" title="MapFn">MapFn</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.map" href="#method.map">map</a>
          <span class="function-params">(<a class="type-name" title="MapFn">MapFn</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Creates an iterator which uses a closure to map each element to another type.</p><p>The returned iterator's type is whatever is returned by the closure.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.rev" href="#method.rev">rev</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.rev" href="#method.rev">rev</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Reverses an iterator's direction.</p><p>Usually, iterators iterate from front to back. After using <code>rev()</code>, an iterator will instead iterate from back to front.</p><p>This is only possible if the iterator has an end, so <code>rev()</code> only works on <code>DoubleEndedIterator</code>s.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="struct SizeHint" href="sus-iter-SizeHint.html">SizeHint</a>
          <a class="function-name" name="method.size_hint" href="#method.size_hint">size_hint</a>
          <span class="function-params">()</span>
          <span class="const">
            const
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="struct SizeHint" href="sus-iter-SizeHint.html">SizeHint</a>
          <a class="function-name" name="method.size_hint" href="#method.size_hint">size_hint</a>
          <span class="function-params">()</span>
          <span class="const">
            const
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="struct SizeHint" href="sus-iter-SizeHint.html">SizeHint</a>
          <a class="function-name" name="method.size_hint" href="#method.size_hint">size_hint</a>
          <span class="function-params">()</span>
          <span class="const">
            const
          </span>
        </div>
        <div class="description">
          <p>Returns the bounds on the remaining length of the iterator.</p><p>Specifically, <code>size_hint()</code> returns a <code>SizeHint</code> with a lower and upper bound.</p><p>The upper bound is an Option&lt;usize&gt;. A None here means that either there is no known upper bound, or the upper bound is larger than usize.</p><p></p><h1>Implementation notes</h1><p></p><p>It is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.</p><p><code>size_hint()</code> is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g., omit bounds checks in unsafe code. An incorrect implementation of <code>size_hint()</code> should not lead to memory safety violations.</p><p>That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the <code>Iterator</code> concept's protocol.</p><p>The default implementation returns <code>lower = 0</code> and <code>upper = None</code> which is correct for any iterator.</p>
        </div>
      </div>
    </div>
  </div>
</body>
