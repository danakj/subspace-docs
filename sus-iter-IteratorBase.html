<head>
  <title>
    sus::iter::IteratorBase
  </title>
  <link rel="stylesheet" href="subdoc-test-style.css">
</head>

<body>
  <div class="type record class">
    <div class="section overview">
      <div class="section-header">
        <span>
          Class
        </span>
        <span><a>sus</a>::<a>iter</a>::<a class="type-name" href="#">IteratorBase</a></span>
      </div>
      <div class="type-signature">
        <span class="class">
          class
        </span>
        <span class="type-name">
          IteratorBase
        </span>
        <div class="record-body">
          { ... };
        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Methods
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.begin" href="#method.begin">begin</a>
          <span class="function-params">()</span>
          <span class="mutable ref">
            &
          </span>
        </div>
        <div class="description">
          <p>Adaptor for use in ranged for loops.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.end" href="#method.end">end</a>
          <span class="function-params">()</span>
          <span class="mutable ref">
            &
          </span>
        </div>
        <div class="description">
          <p>Adaptor for use in ranged for loops.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="Option&lt;Item&gt;">Option&lt;Item&gt;</a>
          <a class="function-name" name="method.next" href="#method.next">next</a>
          <span class="function-params">()</span>
        </div>
        <div class="description">
          <p>Gets the next element from the iterator, if there is one. Otherwise, it returns an Option holding #None.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="struct SizeHint" href="sus-iter-SizeHint.html">SizeHint</a>
          <a class="function-name" name="method.size_hint" href="#method.size_hint">size_hint</a>
          <span class="function-params">()</span>
          <span class="const">
            const
          </span>
        </div>
        <div class="description">
          <p>Returns the bounds on the remaining length of the iterator.</p><p>Specifically, <code>size_hint()</code> returns a <code>SizeHint</code> with a lower and upper bound.</p><p>The upper bound is an Option&lt;usize&gt;. A None here means that either there is no known upper bound, or the upper bound is larger than usize.</p><p></p><h1>Implementation notes</h1><p></p><p>It is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.</p><p><code>size_hint()</code> is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g., omit bounds checks in unsafe code. An incorrect implementation of <code>size_hint()</code> should not lead to memory safety violations.</p><p>That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the <code>Iterator</code> concept's protocol.</p><p>The default implementation returns <code>lower = 0</code> and <code>upper = None</code> which is correct for any iterator.</p>
        </div>
      </div>
    </div>
  </div>
</body>
