<head>
  <title>
    sus::iter::IteratorImpl
  </title>
  <link rel="stylesheet" href="subdoc-test-style.css">
</head>

<body>
  <div class="type record class">
    <div class="section overview">
      <div class="section-header">
        <span>
          Class
        </span>
        <span><a>sus</a>::<a>iter</a>::<a class="type-name" href="#">IteratorImpl</a></span>
      </div>
      <div class="type-signature">
        <span class="class">
          class
        </span>
        <span class="type-name">
          IteratorImpl
        </span>
        <div class="record-body">
          { ... };
        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Methods
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.all" href="#method.all">all</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (Item)&gt;">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.all" href="#method.all">all</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (Item)&gt;">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="description">
          <p>Tests whether all elements of the iterator match a predicate.</p><p>If the predicate returns <code>true</code> for all elements in the iterator, this functions returns <code>true</code>, otherwise <code>false</code>. The function is short-circuiting; it stops iterating on the first <code>false</code> returned from the predicate.</p><p>Returns <code>true</code> if the iterator is empty.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.any" href="#method.any">any</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (Item)&gt;">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="overload">
          <a class="type-name" title="bool">bool</a>
          <a class="function-name" name="method.any" href="#method.any">any</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (Item)&gt;">FnMut&lt;_Bool (Item)&gt;</a>)</span>
        </div>
        <div class="description">
          <p>Tests whether any elements of the iterator match a predicate.</p><p>If the predicate returns <code>true</code> for any elements in the iterator, this functions returns <code>true</code>, otherwise <code>false</code>. The function is short-circuiting; it stops iterating on the first <code>true</code> returned from the predicate.</p><p>Returns <code>false</code> if the iterator is empty.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.begin" href="#method.begin">begin</a>
          <span class="function-params">()</span>
          <span class="mutable ref">
            &
          </span>
        </div>
        <div class="description">
          <p>Adaptor for use in ranged for loops.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.box" href="#method.box">box</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.box" href="#method.box">box</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Wraps the iterator in a new iterator that is trivially relocatable.</p><p>Being trivially relocatable is required to chain the iterator, though methods such as <code>filter()</code>. This method converts the iterator to be trivially relocatable by moving the iterator into heap storage, which implies this does a heap allocation, which is slow compared to working on the stack.</p><p>When possible, favour making the iterator be trivially relocatable by having it iterate over types which are themselves trivially relocatable, instead of using <code>box()</code>. This will give much better performance.</p><p>It's only possible to call this in cases where it would do something useful, that is when the Iterator type is not trivially relocatable.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="FromIterator&lt;Item&gt; auto">FromIterator&lt;Item&gt; auto</a>
          <a class="function-name" name="method.collect" href="#method.collect">collect</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="FromIterator&lt;Item&gt; auto">FromIterator&lt;Item&gt; auto</a>
          <a class="function-name" name="method.collect" href="#method.collect">collect</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Transforms an iterator into a collection.</p><p>collect() can turn anything iterable into a relevant collection. If this is used anything like in Rust, it would be one of the more powerful methods in the subspace library, used in a variety of contexts.</p><p>The most basic pattern in which collect() is used is to turn one collection into another. You take a collection, call iter on it, do a bunch of transformations, and then collect() at the end.</p><p>collect() can also create instances of types that are not typical collections. For example, (TODO: a String can be built from chars, and) an iterator of Result&lt;T, E&gt; items can be collected into Result&lt;Collection&lt;T&gt;, E&gt;. Or an iterator of Option&lt;T&gt; can be collected into Option&lt;Collection&lt;T&gt;&gt;.</p><p>Because collect() is so general, and C++ lacks strong type inference, collect() doesn't know the type of collection that you want to produce, so you will always need to pass it a type argument, such as:</p><pre><code>sus::move(iter).collect&lt;MyContainer&lt;i32&gt;&gt;()
</code></pre><p></p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="Vec">Vec</a>
          <a class="function-name" name="method.collect_vec" href="#method.collect_vec">collect_vec</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="Vec">Vec</a>
          <a class="function-name" name="method.collect_vec" href="#method.collect_vec">collect_vec</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Transforms an iterator into a Vec.</p><p>This function is a shorthand for <code>it.collect&lt;Vec&lt;Item&gt;&gt;()</code> in order to avoid the need for specifying a template argument.</p><p>See <code>collect()</code> for more details.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="struct ::sus::num::usize" href="sus-num-usize.html">usize</a>
          <a class="function-name" name="method.count" href="#method.count">count</a>
          <span class="function-params">()</span>
        </div>
        <div class="overload">
          <a class="type-name" title="struct ::sus::num::usize" href="sus-num-usize.html">usize</a>
          <a class="function-name" name="method.count" href="#method.count">count</a>
          <span class="function-params">()</span>
        </div>
        <div class="description">
          <p>Consumes the iterator, and returns the number of elements that were in it.</p><p>The function walks the iterator until it sees an Option holding #None.</p><p></p><h1>Safety</h1><p></p><p>If the <code>usize</code> type does not have trapping arithmetic enabled, and the iterator has more than <code>usize::MAX</code> elements in it, the value will wrap and be incorrect. Otherwise, <code>usize</code> will catch overflow and panic.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.end" href="#method.end">end</a>
          <span class="function-params">()</span>
          <span class="mutable ref">
            &
          </span>
        </div>
        <div class="description">
          <p>Adaptor for use in ranged for loops.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.filter" href="#method.filter">filter</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (const std::remove_reference_t&lt;Item&gt; &)&gt;">FnMut&lt;_Bool (const std::remove_reference_t&lt;Item&gt; &)&gt;</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.filter" href="#method.filter">filter</a>
          <span class="function-params">(<a class="type-name" title="::sus::fn::FnMut&lt;_Bool (const std::remove_reference_t&lt;Item&gt; &)&gt;">FnMut&lt;_Bool (const std::remove_reference_t&lt;Item&gt; &)&gt;</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Creates an iterator which uses a closure to determine if an element should be yielded.</p><p>Given an element the closure must return true or false. The returned iterator will yield only the elements for which the closure returns true.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="Iter &&">Iter &&</a>
          <a class="function-name" name="method.into_iter" href="#method.into_iter">into_iter</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>An Iterator also satisfies IntoIterator, which simply returns itself.</p><p>sus::iter::IntoIterator trait implementation.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.map" href="#method.map">map</a>
          <span class="function-params">(<a class="type-name" title="MapFn">MapFn</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.map" href="#method.map">map</a>
          <span class="function-params">(<a class="type-name" title="MapFn">MapFn</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Creates an iterator which uses a closure to map each element to another type.</p><p>The returned iterator's type is whatever is returned by the closure.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.reverse" href="#method.reverse">reverse</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="overload">
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.reverse" href="#method.reverse">reverse</a>
          <span class="function-params">()</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
      </div>
    </div>
  </div>
</body>
