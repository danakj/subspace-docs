<!DOCTYPE html>
<meta charset="utf-8"/>
<title>struct is_hashable_data</title>
<link rel="stylesheet" href="../../../clang-doc-default-stylesheet.css"/>
<script src="../../../index.js"></script>
<script src="../../../index_json.js"></script>
<header id="project-title">Subspace</header>
<main>
  <div id="sidebar-left" path="llvm/hashing/detail" class="col-xs-6 col-sm-3 col-md-2 sidebar sidebar-offcanvas-left"></div>
  <div id="main-content" class="col-xs-12 col-sm-9 col-md-8 main-content">
    <h1>struct is_hashable_data</h1>
    <p>Defined at line 362 of file /usr/lib/llvm-16/include/llvm/ADT/Hashing.h</p>
    <div>
      <div>
        <p> Special case std::pair to detect when both types are viable and when there is no alignment-derived padding in the pair. This is a bit of a lie because std::pair isn&apos;t truly POD, but it&apos;s close enough in all reasonable implementations for our use case of hashing the underlying data.</p>
      </div>
    </div>
    <p>Inherits from std::integral_constant&lt;_Bool, (is_hashable_data&lt;T&gt;::value &amp;&amp; is_hashable_data&lt;U&gt;::value &amp;&amp; (sizeof(T) + sizeof(U)) == sizeof(std::pair&lt;T, U&gt;))&gt;</p>
  </div>
  <div id="sidebar-right" class="col-xs-6 col-sm-6 col-md-2 sidebar sidebar-offcanvas-right"></div>
</main>
<footer>
  <span class="no-break">Ubuntu clang-doc version 16.0.0 (++20230103042323+3bbdd9f506c1-1~exp1~20230103042429.660)</span>
</footer>
<!DOCTYPE html>
<meta charset="utf-8"/>
<title>struct is_hashable_data</title>
<link rel="stylesheet" href="../../../clang-doc-default-stylesheet.css"/>
<script src="../../../index.js"></script>
<script src="../../../index_json.js"></script>
<header id="project-title">Subspace</header>
<main>
  <div id="sidebar-left" path="llvm/hashing/detail" class="col-xs-6 col-sm-3 col-md-2 sidebar sidebar-offcanvas-left"></div>
  <div id="main-content" class="col-xs-12 col-sm-9 col-md-8 main-content">
    <h1>struct is_hashable_data</h1>
    <p>Defined at line 353 of file /usr/lib/llvm-16/include/llvm/ADT/Hashing.h</p>
    <div>
      <div>
        <p> Trait to indicate whether a type&apos;s bits can be hashed directly.</p>
        <p> A type trait which is true if we want to combine values for hashing by reading the underlying data. It is false if values of this type must first be passed to hash_value, and the resulting hash_codes combined.</p>
        <p> FIXME: We want to replace is_integral_or_enum and is_pointer here with a predicate which asserts that comparing the underlying storage of two values of the type for equality is equivalent to comparing the two values for equality. For all the platforms we care about, this holds for integers and pointers, but there are platforms where it doesn&apos;t and we would like to support user-defined types which happen to satisfy this property.</p>
      </div>
    </div>
    <p>Inherits from std::integral_constant&lt;_Bool, ((is_integral_or_enum&lt;T&gt;::value || std::is_pointer&lt;T&gt;::value) &amp;&amp; 64 % sizeof(T) == 0)&gt;</p>
  </div>
  <div id="sidebar-right" class="col-xs-6 col-sm-6 col-md-2 sidebar sidebar-offcanvas-right"></div>
</main>
<footer>
  <span class="no-break">Ubuntu clang-doc version 16.0.0 (++20230103042323+3bbdd9f506c1-1~exp1~20230103042429.660)</span>
</footer>
