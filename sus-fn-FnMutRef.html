<head>
  <title>
    sus::fn::FnMutRef
  </title>
  <link rel="stylesheet" href="subdoc-test-style.css">
</head>

<body>
  <div class="type record class">
    <div class="section overview">
      <div class="section-header">
        <span>
          Class
        </span>
        <span><a>sus</a>::<a>fn</a>::<a class="type-name" href="#">FnMutRef</a></span>
      </div>
      <div class="type-signature">
        <span class="class">
          class
        </span>
        <span class="type-name">
          FnMutRef
        </span>
        <div class="record-body">
          { ... };
        </div>
      </div>
      <div class="description">
        <p>A closure that erases the type of the internal callable object (lambda) that may mutate internal state. A FnMutRef may be called multiple times, and may return a different value on each call with the same inputs.</p><p>FnRef can be used as a FnMutRef, which can be used as a FnOnceRef. Lambdas can be converted into a FnOnceRef, FnMutRef, or FnRef directly.</p><p>FnOnceRef, FnMutRef and FnRef are only safe to appear as lvalues when they are a function parameter, and a clang-tidy check is provided to enforce this. They only hold a reference to the underlying lambda so they must not outlive the lambda.</p><p></p><h1>Why can a "const" FnRef convert to a mutable FnMutRef or FnOnceRef?</h1><p></p><p>A FnMutRef or FnOnceRef is _allowed_ to mutate its storage, but a "const" FnRef closure would just choose not to do so.</p><p>However, a <code>const FnRef</code> requires that the storage is not mutated, so it is not useful if converted to a <code>const FnMutRef</code> or <code>const FnOnceRef</code> which are only callable as mutable objects.</p><p></p><h1>Null pointers</h1><p></p><p>A null function pointer is not allowed, constructing a FnOnceRef from a null pointer will panic.</p>
      </div>
    </div>
    <div class="section methods static">
      <div class="section-header">
        Static Methods
      </div>
      <div class="section-item">
        <div class="overload">
          <span class="static">
            static
          </span>
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.static.from" href="#method.static.from">from</a>
          <span class="function-params">(<a class="type-name" title="__private::FunctionPointer&lt;RCallArgs...&gt; auto">FunctionPointer&lt;RCallArgs...&gt; auto</a>)</span>
        </div>
        <div class="overload">
          <span class="static">
            static
          </span>
          <a class="type-name" title="auto">auto</a>
          <a class="function-name" name="method.static.from" href="#method.static.from">from</a>
          <span class="function-params">(<a class="type-name" title="F &&">F &&</a>)</span>
        </div>
        <div class="description">
          <p><code>sus::construct::From</code> trait implementation.</p><p>FnMutRef satisfies <code>From&lt;T&gt;</code> for the same types that it is constructible from: function pointers that exactly match its own signature, and callable objects (lambdas) that are compatible with its signature.</p>
        </div>
      </div>
    </div>
    <div class="section methods nonstatic">
      <div class="section-header">
        Methods
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt;" href="sus-fn-FnMutRef.html">FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt;</a>
          <a class="function-name" name="method.clone" href="#method.clone">clone</a>
          <span class="function-params">()</span>
          <span class="const">
            const
          </span>
        </div>
        <div class="description">
          <p>sus::mem::Clone trait.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="R">R</a>
          <a class="function-name" name="method.operator()" href="#method.operator()">operator()</a>
          <span class="function-params">(<a class="type-name" title="CallArgs...">CallArgs...</a>)</span>
          <span class="mutable ref">
            &
          </span>
        </div>
        <div class="description">
          <p>Runs the closure.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="R">R</a>
          <a class="function-name" name="method.operator().1" href="#method.operator().1">operator()</a>
          <span class="function-params">(<a class="type-name" title="CallArgs...">CallArgs...</a>)</span>
          <span class="mutable rref">
            &&
          </span>
        </div>
        <div class="description">
          <p>Runs and consumes the closure.</p>
        </div>
      </div>
      <div class="section-item">
        <div class="overload">
          <a class="type-name" title="FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt; &" href="sus-fn-FnMutRef.html">FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt; &</a>
          <a class="function-name" name="method.operator=" href="#method.operator=">operator=</a>
          <span class="function-params">(<a class="type-name" title="FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt; &&" href="sus-fn-FnMutRef.html">FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt; &&</a>)</span>
        </div>
        <div class="overload">
          <a class="type-name" title="FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt; &" href="sus-fn-FnMutRef.html">FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt; &</a>
          <a class="function-name" name="method.operator=" href="#method.operator=">operator=</a>
          <span class="function-params">(<a class="type-name" title="const FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt; &" href="sus-fn-FnMutRef.html">const FnMutRef&lt;type-parameter-0-0 (type-parameter-0-1...)&gt; &</a>)</span>
        </div>
      </div>
    </div>
  </div>
</body>
