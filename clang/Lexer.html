<!DOCTYPE html>
<meta charset="utf-8"/>
<title>class Lexer</title>
<link rel="stylesheet" href="../clang-doc-default-stylesheet.css"/>
<script src="../index.js"></script>
<script src="../index_json.js"></script>
<header id="project-title">Subspace</header>
<main>
  <div id="sidebar-left" path="clang" class="col-xs-6 col-sm-3 col-md-2 sidebar sidebar-offcanvas-left"></div>
  <div id="main-content" class="col-xs-12 col-sm-9 col-md-8 main-content">
    <h1>class Lexer</h1>
    <p>Defined at line 78 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
    <div>
      <div>
        <p> Lexer - This provides a simple interface that turns a text buffer into a stream of tokens.  This provides no support for file reading or buffering, or buffering/seeking of tokens, only forward lexing is supported.  It relies on the specified Preprocessor object to handle preprocessor directives, etc.</p>
      </div>
    </div>
    <p>
      Inherits from 
      <a href="PreprocessorLexer.html">PreprocessorLexer</a>
    </p>
    <h2 id="Functions">Functions</h2>
    <div>
      <h3 id="7C2F1FF9550FD1C6B3993D5E7551834495A626AE">Lexer</h3>
      <p>
        public void Lexer(
        <a href="FileID.html">FileID</a>
         FID, const llvm::MemoryBufferRef &amp; InputFile, Preprocessor &amp; PP, _Bool IsFirstIncludeOfFile)
      </p>
      <div>
        <div>
          <p> Lexer constructor - Create a new lexer object for the specified buffer with the specified preprocessor managing the lexing process.  This lexer assumes that the associated file buffer and Preprocessor objects will outlive it, so it doesn&apos;t take ownership of either of them.</p>
        </div>
      </div>
      <h3 id="8A10117108ED6368FA74508E190562EBC8287B99">Lexer</h3>
      <p>
        public void Lexer(
        <a href="SourceLocation.html">SourceLocation</a>
         FileLoc, const LangOptions &amp; LangOpts, const char * BufStart, const char * BufPtr, const char * BufEnd, _Bool IsFirstIncludeOfFile)
      </p>
      <div>
        <div>
          <p> Lexer constructor - Create a new raw lexer object.  This object is only suitable for calls to &apos;LexFromRawLexer&apos;.  This lexer assumes that the text range will outlive it, so it doesn&apos;t take ownership of it.</p>
        </div>
      </div>
      <h3 id="0E8DDAD1EE68C2A6C60487DE0441A47361D17211">Lexer</h3>
      <p>
        public void Lexer(
        <a href="FileID.html">FileID</a>
         FID, const llvm::MemoryBufferRef &amp; FromFile, const SourceManager &amp; SM, const LangOptions &amp; LangOpts, _Bool IsFirstIncludeOfFile)
      </p>
      <div>
        <div>
          <p> Lexer constructor - Create a new raw lexer object.  This object is only suitable for calls to &apos;LexFromRawLexer&apos;.  This lexer assumes that the text range will outlive it, so it doesn&apos;t take ownership of it.</p>
        </div>
      </div>
      <h3 id="EBD9851000A368D519DB18C63D8A9A079A47FAE8">Lexer</h3>
      <p>public void Lexer(const Lexer &amp; )</p>
      <p>Defined at line 184 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <h3 id="6DF91BFDF91C5D12FD2BFCE26DC48695B4B1BCDF">operator=</h3>
      <p>public Lexer &amp; operator=(const Lexer &amp; )</p>
      <p>Defined at line 185 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <h3 id="BB8F43EDDDC7A3DE8EDF0DDF9B58D467FEBAF41C">Create_PragmaLexer</h3>
      <p>
        public Lexer * Create_PragmaLexer(
        <a href="SourceLocation.html">SourceLocation</a>
         SpellingLoc, 
        <a href="SourceLocation.html">SourceLocation</a>
         ExpansionLocStart, 
        <a href="SourceLocation.html">SourceLocation</a>
         ExpansionLocEnd, unsigned int TokLen, Preprocessor &amp; PP)
      </p>
      <div>
        <div>
          <p> Create_PragmaLexer: Lexer constructor - Create a new lexer object for _Pragma expansion.  This has a variety of magic semantics that this method sets up.  It returns a new&apos;d Lexer that must be delete&apos;d when done.</p>
        </div>
      </div>
      <h3 id="CA1B8F57C02512237AB981FC537116F7665E71F2">getFileLoc</h3>
      <p>
        public 
        <a href="SourceLocation.html">SourceLocation</a>
         getFileLoc()
      </p>
      <p>Defined at line 199 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> getFileLoc - Return the File Location for the file we are lexing out of. The physical location encodes the location where the characters come from, the virtual location encodes where we should *claim* the characters came from.  Currently this is only used by _Pragma handling.</p>
        </div>
      </div>
      <h3 id="F2C206180ACB63D04731969AD4C35A46ED1F5BD4">isPragmaLexer</h3>
      <p>public _Bool isPragmaLexer()</p>
      <p>Defined at line 225 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> isPragmaLexer - Returns true if this Lexer is being used to lex a pragma.</p>
        </div>
      </div>
      <h3 id="3FC8015748D798AD5817C36D27F8A418B40B73B4">LexFromRawLexer</h3>
      <p>public _Bool LexFromRawLexer(Token &amp; Result)</p>
      <p>Defined at line 236 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> LexFromRawLexer - Lex a token from a designated raw lexer (one with no associated preprocessor object.  Return true if the &apos;next character to read&apos; pointer points at the end of the lexer buffer, false otherwise.</p>
        </div>
      </div>
      <h3 id="9CEA11872CBE89F5095D91BB4C13AD5CB5ABED6A">isKeepWhitespaceMode</h3>
      <p>public _Bool isKeepWhitespaceMode()</p>
      <p>Defined at line 248 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> isKeepWhitespaceMode - Return true if the lexer should return tokens for every character in the file, including whitespace and comments.  This should only be used in raw mode, as the preprocessor is not prepared to deal with the excess tokens.</p>
        </div>
      </div>
      <h3 id="E552A55620BD72DE8EE19B3622D3B7844E5DF5F4">SetKeepWhitespaceMode</h3>
      <p>public void SetKeepWhitespaceMode(_Bool Val)</p>
      <p>Defined at line 254 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> SetKeepWhitespaceMode - This method lets clients enable or disable whitespace retention mode.</p>
        </div>
      </div>
      <h3 id="2E6D48966064B6300B8FB7AD4749CE6332E71437">inKeepCommentMode</h3>
      <p>public _Bool inKeepCommentMode()</p>
      <p>Defined at line 262 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> inKeepCommentMode - Return true if the lexer should return comments as tokens.</p>
        </div>
      </div>
      <h3 id="53A17153A73BB0DDC1701C8DBB894C87BE50D8ED">SetCommentRetentionState</h3>
      <p>public void SetCommentRetentionState(_Bool Mode)</p>
      <p>Defined at line 269 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> SetCommentRetentionMode - Change the comment retention mode of the lexer to the specified mode.  This is really only useful when lexing in raw mode, because otherwise the lexer needs to manage this.</p>
        </div>
      </div>
      <h3 id="E45E70BE40AEF650C0EBB3E86EE9F98AA315F5BE">resetExtendedTokenMode</h3>
      <p>public void resetExtendedTokenMode()</p>
      <div>
        <div>
          <p> Sets the extended token mode back to its initial value, according to the language options and preprocessor. This controls whether the lexer produces comment and whitespace tokens.</p>
          <p> This requires the lexer to have an associated preprocessor. A standalone lexer has nothing to reset to.</p>
        </div>
      </div>
      <h3 id="B5BA4554E5820C8EDDDD545EEF3539C8A046C12B">getBuffer</h3>
      <p>
        public 
        <a href="../llvm/StringRef.html">StringRef</a>
         getBuffer()
      </p>
      <p>Defined at line 284 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> Gets source code buffer.</p>
        </div>
      </div>
      <h3 id="EBE702361A4494CB4555D7D953494FFCF7F3D40D">ReadToEndOfLine</h3>
      <p>public void ReadToEndOfLine(SmallVectorImpl&lt;char&gt; * Result)</p>
      <div>
        <div>
          <p> ReadToEndOfLine - Read the rest of the current preprocessor line as an uninterpreted string.  This switches the lexer out of directive mode.</p>
        </div>
      </div>
      <h3 id="E5FAD99F7E9F683B9A00269D969264B2EE9A058C">Diag</h3>
      <p>
        public 
        <a href="DiagnosticBuilder.html">DiagnosticBuilder</a>
         Diag(const char * Loc, unsigned int DiagID)
      </p>
      <div>
        <div>
          <p> Diag - Forwarding function for diagnostics.  This translate a source position in the current buffer into a SourceLocation object for rendering.</p>
        </div>
      </div>
      <h3 id="7FBE266139F163FA60A15075F5609CAFC9FD08FB">getSourceLocation</h3>
      <p>
        public 
        <a href="SourceLocation.html">SourceLocation</a>
         getSourceLocation(const char * Loc, unsigned int TokLen)
      </p>
      <div>
        <div>
          <p> getSourceLocation - Return a source location identifier for the specified offset in the current file.</p>
        </div>
      </div>
      <h3 id="42E06896450B3968A86955E299B0459EC3C9138C">getSourceLocation</h3>
      <p>
        public 
        <a href="SourceLocation.html">SourceLocation</a>
         getSourceLocation()
      </p>
      <p>Defined at line 303 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> getSourceLocation - Return a source location for the next character in the current file.</p>
        </div>
      </div>
      <h3 id="A61A5CEF4EC6A8C8DAD752B302C398FF1E0865E1">getBufferLocation</h3>
      <p>public const char * getBufferLocation()</p>
      <p>Defined at line 308 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> Return the current location in the buffer.</p>
        </div>
      </div>
      <h3 id="A295C68FA66C1BABB1007EC560344E382F7FBE54">getCurrentBufferOffset</h3>
      <p>public unsigned int getCurrentBufferOffset()</p>
      <p>Defined at line 311 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> Returns the current lexing offset.</p>
        </div>
      </div>
      <h3 id="962746344CE8BD468F106F3C9578D1A2B449F817">seek</h3>
      <p>public void seek(unsigned int Offset, _Bool IsAtStartOfLine)</p>
      <div>
        <div>
          <p> Set the lexer&apos;s buffer pointer to </p>
        </div>
      </div>
      <h3 id="27B7B4FAC16ADC47BC59897035BCE2D644DC3DA9">Stringify</h3>
      <p>
        public 
        <a href="../std/__cxx11/basic_string.html">basic_string</a>
         Stringify(
        <a href="../llvm/StringRef.html">StringRef</a>
         Str, _Bool Charify)
      </p>
      <div>
        <div>
          <p> Stringify - Convert the specified string into a C string by i) escaping &apos;\&apos; and &quot; characters and ii) replacing newline character(s) with &quot;\n&quot;. If Charify is true, this escapes the &apos; character instead of &quot;.</p>
        </div>
      </div>
      <h3 id="045D2A13EDA994A6405F8935BE94CD14E182B0CF">Stringify</h3>
      <p>public void Stringify(SmallVectorImpl&lt;char&gt; &amp; Str)</p>
      <div>
        <div>
          <p> Stringify - Convert the specified string into a C string by i) escaping &apos;\&apos; and &quot; characters and ii) replacing newline character(s) with &quot;\n&quot;.</p>
        </div>
      </div>
      <h3 id="063E622DABEDAD7DCB95ABA85EF4B1C7B59EA72C">getSpelling</h3>
      <p>public unsigned int getSpelling(const Token &amp; Tok, const char *&amp; Buffer, const SourceManager &amp; SourceMgr, const LangOptions &amp; LangOpts, _Bool * Invalid)</p>
      <div>
        <div>
          <p> getSpelling - This method is used to get the spelling of a token into a preallocated buffer, instead of as an std::string.  The caller is required to allocate enough space for the token, which is guaranteed to be at least Tok.getLength() bytes long.  The length of the actual result is returned.</p>
          <p> Note that this method may do two possible things: it may either fill in the buffer specified with characters, or it may *change the input pointer* to point to a constant buffer with the data already in it (avoiding a copy).  The caller is not allowed to modify the returned buffer pointer if an internal buffer is returned.</p>
        </div>
      </div>
      <h3 id="8F0902B472DC34A7394CF2AD33834C5E34349AC5">getSpelling</h3>
      <p>
        public 
        <a href="../std/__cxx11/basic_string.html">basic_string</a>
         getSpelling(const Token &amp; Tok, const SourceManager &amp; SourceMgr, const LangOptions &amp; LangOpts, _Bool * Invalid)
      </p>
      <div>
        <div>
          <p> getSpelling() - Return the &apos;spelling&apos; of the Tok token.  The spelling of a token is the characters used to represent the token in the source file after trigraph expansion and escaped-newline folding.  In particular, this wants to get the true, uncanonicalized, spelling of things like digraphs UCNs, etc.</p>
        </div>
      </div>
      <h3 id="D9A3FF5D609D4590267FBA65E174F4D07FA0F111">getSpelling</h3>
      <p>
        public 
        <a href="../llvm/StringRef.html">StringRef</a>
         getSpelling(
        <a href="SourceLocation.html">SourceLocation</a>
         loc, SmallVectorImpl&lt;char&gt; &amp; buffer, const SourceManager &amp; SM, const LangOptions &amp; options, _Bool * invalid)
      </p>
      <div>
        <div>
          <p> getSpelling - This method is used to get the spelling of the token at the given source location.  If, as is usually true, it is not necessary to copy any data, then the returned string may not point into the provided buffer.</p>
          <p> This method lexes at the expansion depth of the given location and does not jump to the expansion or spelling location.</p>
        </div>
      </div>
      <h3 id="D7EEE864DC0075D3A2CAC5314D4AF0DD2B4AE460">MeasureTokenLength</h3>
      <p>
        public unsigned int MeasureTokenLength(
        <a href="SourceLocation.html">SourceLocation</a>
         Loc, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <div>
        <div>
          <p> MeasureTokenLength - Relex the token at the specified location and return its length in bytes in the input file.  If the token needs cleaning (e.g. includes a trigraph or an escaped newline) then this count includes bytes that are part of that.</p>
        </div>
      </div>
      <h3 id="82BDD31062DA02DC49D2D25642781781ABF4A50B">getRawToken</h3>
      <p>
        public _Bool getRawToken(
        <a href="SourceLocation.html">SourceLocation</a>
         Loc, Token &amp; Result, const SourceManager &amp; SM, const LangOptions &amp; LangOpts, _Bool IgnoreWhiteSpace)
      </p>
      <div>
        <div>
          <p> Relex the token at the specified location.</p>
        </div>
      </div>
      <h3 id="A6FD3A24A59826D891E2A052290F4FA27BF125D5">GetBeginningOfToken</h3>
      <p>
        public 
        <a href="SourceLocation.html">SourceLocation</a>
         GetBeginningOfToken(
        <a href="SourceLocation.html">SourceLocation</a>
         Loc, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <div>
        <div>
          <p> Given a location any where in a source buffer, find the location that corresponds to the beginning of the token in which the original source location lands.</p>
        </div>
      </div>
      <h3 id="F931669EBEAE71C9E2FC8395A410E4955A7E4D78">getTokenPrefixLength</h3>
      <p>
        public unsigned int getTokenPrefixLength(
        <a href="SourceLocation.html">SourceLocation</a>
         TokStart, unsigned int CharNo, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <div>
        <div>
          <p> Get the physical length (including trigraphs and escaped newlines) of the first  characters of the token starting at TokStart.</p>
        </div>
      </div>
      <h3 id="14A21208B2C263E5B9F06892A4D65C152C8FD687">AdvanceToTokenCharacter</h3>
      <p>
        public 
        <a href="SourceLocation.html">SourceLocation</a>
         AdvanceToTokenCharacter(
        <a href="SourceLocation.html">SourceLocation</a>
         TokStart, unsigned int Characters, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <p>Defined at line 399 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> AdvanceToTokenCharacter - If the current SourceLocation specifies a location at the start of a token, return a new location that specifies a character within the token.  This handles trigraphs and escaped newlines.</p>
        </div>
      </div>
      <h3 id="8F33593147E24DB16C2B439B2F1BC3FC75387FAE">getLocForEndOfToken</h3>
      <p>
        public 
        <a href="SourceLocation.html">SourceLocation</a>
         getLocForEndOfToken(
        <a href="SourceLocation.html">SourceLocation</a>
         Loc, unsigned int Offset, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <div>
        <div>
          <p> Computes the source location just past the end of the token at this source location.</p>
          <p> This routine can be used to produce a source location that points just past the end of the token referenced by  and is generally used when a diagnostic needs to point just after a token where it expected something different that it received. If the returned source location would not be meaningful (e.g., if it points into a macro), this routine returns an invalid source location.</p>
        </div>
      </div>
      <h3 id="3D9636BAC2FF3CF2B1FDCA9A913BF576BFDF669B">getAsCharRange</h3>
      <p>
        public 
        <a href="CharSourceRange.html">CharSourceRange</a>
         getAsCharRange(
        <a href="SourceRange.html">SourceRange</a>
         Range, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <p>Defined at line 430 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> Given a token range, produce a corresponding CharSourceRange that is not a token range. This allows the source range to be used by components that don&apos;t have access to the lexer and thus can&apos;t find the end of the range for themselves.</p>
        </div>
      </div>
      <h3 id="F8ED15980915E888DC541308FF93CC0D22C9FB57">getAsCharRange</h3>
      <p>
        public 
        <a href="CharSourceRange.html">CharSourceRange</a>
         getAsCharRange(
        <a href="CharSourceRange.html">CharSourceRange</a>
         Range, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <p>Defined at line 438 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <h3 id="124B71D146C9AE1C0C53B3B0559E37334592FF15">isAtStartOfMacroExpansion</h3>
      <p>
        public _Bool isAtStartOfMacroExpansion(
        <a href="SourceLocation.html">SourceLocation</a>
         loc, const SourceManager &amp; SM, const LangOptions &amp; LangOpts, SourceLocation * MacroBegin)
      </p>
      <div>
        <div>
          <p> Returns true if the given MacroID location points at the first token of the macro expansion.</p>
        </div>
      </div>
      <h3 id="30D22378A571F53D3380FB0BAF0DA8FA2A7D24BD">isAtEndOfMacroExpansion</h3>
      <p>
        public _Bool isAtEndOfMacroExpansion(
        <a href="SourceLocation.html">SourceLocation</a>
         loc, const SourceManager &amp; SM, const LangOptions &amp; LangOpts, SourceLocation * MacroEnd)
      </p>
      <div>
        <div>
          <p> Returns true if the given MacroID location points at the last token of the macro expansion.</p>
        </div>
      </div>
      <h3 id="099400063BE4160E2C380CAA0EEF38F1A1A35039">makeFileCharRange</h3>
      <p>
        public 
        <a href="CharSourceRange.html">CharSourceRange</a>
         makeFileCharRange(
        <a href="CharSourceRange.html">CharSourceRange</a>
         Range, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <div>
        <div>
          <p> Accepts a range and returns a character range with file locations.</p>
          <p> Returns a null range if a part of the range resides inside a macro expansion or the range does not reside on the same FileID.</p>
          <p> This function is trying to deal with macros and return a range based on file locations. The cases where it can successfully handle macros are:</p>
          <p> -begin or end range lies at the start or end of a macro expansion, in  which case the location will be set to the expansion point, e.g:#define M 1 2    a M If you have a range [a, 2] (where 2 came from the macro), the function will return a range for &quot;a M&quot; if you have range [a, 1], the function will fail because the range overlaps with only a part of the macro</p>
          <p> -The macro is a function macro and the range can be mapped to the macro  arguments, e.g:#define M 1 2#define FM(x) x    FM(a b M) if you have range [b, 2], the function will return the file range &quot;b M&quot; inside the macro arguments. if you have range [a, 2], the function will return the file range &quot;FM(a b M)&quot; since the range includes all of the macro expansion.</p>
        </div>
      </div>
      <h3 id="7EAAFF561CCA389BC38365D460114679E343162B">getSourceText</h3>
      <p>
        public 
        <a href="../llvm/StringRef.html">StringRef</a>
         getSourceText(
        <a href="CharSourceRange.html">CharSourceRange</a>
         Range, const SourceManager &amp; SM, const LangOptions &amp; LangOpts, _Bool * Invalid)
      </p>
      <div>
        <div>
          <p> Returns a string for the source that the range encompasses.</p>
        </div>
      </div>
      <h3 id="B9B240CE1EB62455FDBC076BD40A4A91B285B2F9">getImmediateMacroName</h3>
      <p>
        public 
        <a href="../llvm/StringRef.html">StringRef</a>
         getImmediateMacroName(
        <a href="SourceLocation.html">SourceLocation</a>
         Loc, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <div>
        <div>
          <p> Retrieve the name of the immediate macro expansion.</p>
          <p> This routine starts from a source location, and finds the name of the macro responsible for its immediate expansion. It looks through any intervening macro argument expansions to compute this. It returns a StringRef which refers to the SourceManager-owned buffer of the source where that macro name is spelled. Thus, the result shouldn&apos;t out-live that SourceManager.</p>
        </div>
      </div>
      <h3 id="EACFF37D2D6B1D3F65DAD7A946BB5812C9D0039D">getImmediateMacroNameForDiagnostics</h3>
      <p>
        public 
        <a href="../llvm/StringRef.html">StringRef</a>
         getImmediateMacroNameForDiagnostics(
        <a href="SourceLocation.html">SourceLocation</a>
         Loc, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <div>
        <div>
          <p> Retrieve the name of the immediate macro expansion.</p>
          <p> This routine starts from a source location, and finds the name of the macro responsible for its immediate expansion. It looks through any intervening macro argument expansions to compute this. It returns a StringRef which refers to the SourceManager-owned buffer of the source where that macro name is spelled. Thus, the result shouldn&apos;t out-live that SourceManager.</p>
          <p> This differs from Lexer::getImmediateMacroName in that any macro argument location will result in the topmost function macro that accepted it. e.g.</p>
          <p> for location of &apos;foo&apos; token, this function will return &quot;MAC1&quot; while Lexer::getImmediateMacroName will return &quot;MAC2&quot;.</p>
        </div>
      </div>
      <h3 id="9977FC43D5174F76E6220476DA477BB591CE04CA">ComputePreamble</h3>
      <p>
        public 
        <a href="PreambleBounds.html">PreambleBounds</a>
         ComputePreamble(
        <a href="../llvm/StringRef.html">StringRef</a>
         Buffer, const LangOptions &amp; LangOpts, unsigned int MaxLines)
      </p>
      <div>
        <div>
          <p> Compute the preamble of the given file.</p>
          <p> The preamble of a file contains the initial comments, include directives, and other preprocessor directives that occur before the code in this particular file actually begins. The preamble of the main source file is a potential prefix header.</p>
        </div>
      </div>
      <h3 id="A36AAF92A0D407E3DBCA3136A47675D35580E820">findNextToken</h3>
      <p>
        public Optional&lt;Token&gt; findNextToken(
        <a href="SourceLocation.html">SourceLocation</a>
         Loc, const SourceManager &amp; SM, const LangOptions &amp; LangOpts)
      </p>
      <div>
        <div>
          <p> Finds the token that comes right after the given location.</p>
          <p> Returns the next token, or none if the location is inside a macro.</p>
        </div>
      </div>
      <h3 id="B1528AB7EA001D3F5E830D3268F90BA6F2714DFB">findLocationAfterToken</h3>
      <p>
        public 
        <a href="SourceLocation.html">SourceLocation</a>
         findLocationAfterToken(
        <a href="SourceLocation.html">SourceLocation</a>
         loc, 
        <a href="../clang/tok/TokenKind.html">TokenKind</a>
         TKind, const SourceManager &amp; SM, const LangOptions &amp; LangOpts, _Bool SkipTrailingWhitespaceAndNewLine)
      </p>
      <div>
        <div>
          <p> Checks that the given token is the first token that occurs after the given location (this excludes comments and whitespace). Returns the location immediately after the specified token. If the token is not found or the location is inside a macro, the returned source location will be invalid.</p>
        </div>
      </div>
      <h3 id="70F988EB3DD6B9B723E6ADF96B46F0C64DCDFC08">isAsciiIdentifierContinueChar</h3>
      <p>public _Bool isAsciiIdentifierContinueChar(char c, const LangOptions &amp; LangOpts)</p>
      <div>
        <div>
          <p> Returns true if the given character could appear in an identifier.</p>
        </div>
      </div>
      <h3 id="CEF30CF850A1591589FA5028F13C02A2270833E2">isNewLineEscaped</h3>
      <p>public _Bool isNewLineEscaped(const char * BufferStart, const char * Str)</p>
      <div>
        <div>
          <p> Checks whether new line pointed by Str is preceded by escape sequence.</p>
        </div>
      </div>
      <h3 id="88E226BE5692DF200287C06032B4BE5BC613F76F">getCharAndSizeNoWarn</h3>
      <p>public char getCharAndSizeNoWarn(const char * Ptr, unsigned int &amp; Size, const LangOptions &amp; LangOpts)</p>
      <p>Defined at line 580 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> getCharAndSizeNoWarn - Like the getCharAndSize method, but does not ever emit a warning.</p>
        </div>
      </div>
      <h3 id="7AAEE959A1B59428FEE2CA7B5D60EE4661673CBB">getIndentationForLine</h3>
      <p>
        public 
        <a href="../llvm/StringRef.html">StringRef</a>
         getIndentationForLine(
        <a href="SourceLocation.html">SourceLocation</a>
         Loc, const SourceManager &amp; SM)
      </p>
      <div>
        <div>
          <p> Returns the leading whitespace for line that corresponds to the given location </p>
        </div>
      </div>
      <h3 id="010DAC6219F8CFEA580D4FF025D08CE850155057">isFirstTimeLexingFile</h3>
      <p>public _Bool isFirstTimeLexingFile()</p>
      <p>Defined at line 599 of file /usr/lib/llvm-16/include/clang/Lex/Lexer.h</p>
      <div>
        <div>
          <p> Check if this is the first time we&apos;re lexing the input file.</p>
        </div>
      </div>
    </div>
  </div>
  <div id="sidebar-right" class="col-xs-6 col-sm-6 col-md-2 sidebar sidebar-offcanvas-right">
    <ol>
      <li>
        <span>
          <a href="#Functions">Functions</a>
        </span>
        <ul>
          <li>
            <span>
              <a href="#7C2F1FF9550FD1C6B3993D5E7551834495A626AE">Lexer</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#8A10117108ED6368FA74508E190562EBC8287B99">Lexer</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#0E8DDAD1EE68C2A6C60487DE0441A47361D17211">Lexer</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#EBD9851000A368D519DB18C63D8A9A079A47FAE8">Lexer</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#6DF91BFDF91C5D12FD2BFCE26DC48695B4B1BCDF">operator=</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#BB8F43EDDDC7A3DE8EDF0DDF9B58D467FEBAF41C">Create_PragmaLexer</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#CA1B8F57C02512237AB981FC537116F7665E71F2">getFileLoc</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#F2C206180ACB63D04731969AD4C35A46ED1F5BD4">isPragmaLexer</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#3FC8015748D798AD5817C36D27F8A418B40B73B4">LexFromRawLexer</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#9CEA11872CBE89F5095D91BB4C13AD5CB5ABED6A">isKeepWhitespaceMode</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#E552A55620BD72DE8EE19B3622D3B7844E5DF5F4">SetKeepWhitespaceMode</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#2E6D48966064B6300B8FB7AD4749CE6332E71437">inKeepCommentMode</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#53A17153A73BB0DDC1701C8DBB894C87BE50D8ED">SetCommentRetentionState</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#E45E70BE40AEF650C0EBB3E86EE9F98AA315F5BE">resetExtendedTokenMode</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#B5BA4554E5820C8EDDDD545EEF3539C8A046C12B">getBuffer</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#EBE702361A4494CB4555D7D953494FFCF7F3D40D">ReadToEndOfLine</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#E5FAD99F7E9F683B9A00269D969264B2EE9A058C">Diag</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#7FBE266139F163FA60A15075F5609CAFC9FD08FB">getSourceLocation</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#42E06896450B3968A86955E299B0459EC3C9138C">getSourceLocation</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#A61A5CEF4EC6A8C8DAD752B302C398FF1E0865E1">getBufferLocation</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#A295C68FA66C1BABB1007EC560344E382F7FBE54">getCurrentBufferOffset</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#962746344CE8BD468F106F3C9578D1A2B449F817">seek</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#27B7B4FAC16ADC47BC59897035BCE2D644DC3DA9">Stringify</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#045D2A13EDA994A6405F8935BE94CD14E182B0CF">Stringify</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#063E622DABEDAD7DCB95ABA85EF4B1C7B59EA72C">getSpelling</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#8F0902B472DC34A7394CF2AD33834C5E34349AC5">getSpelling</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#D9A3FF5D609D4590267FBA65E174F4D07FA0F111">getSpelling</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#D7EEE864DC0075D3A2CAC5314D4AF0DD2B4AE460">MeasureTokenLength</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#82BDD31062DA02DC49D2D25642781781ABF4A50B">getRawToken</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#A6FD3A24A59826D891E2A052290F4FA27BF125D5">GetBeginningOfToken</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#F931669EBEAE71C9E2FC8395A410E4955A7E4D78">getTokenPrefixLength</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#14A21208B2C263E5B9F06892A4D65C152C8FD687">AdvanceToTokenCharacter</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#8F33593147E24DB16C2B439B2F1BC3FC75387FAE">getLocForEndOfToken</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#3D9636BAC2FF3CF2B1FDCA9A913BF576BFDF669B">getAsCharRange</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#F8ED15980915E888DC541308FF93CC0D22C9FB57">getAsCharRange</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#124B71D146C9AE1C0C53B3B0559E37334592FF15">isAtStartOfMacroExpansion</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#30D22378A571F53D3380FB0BAF0DA8FA2A7D24BD">isAtEndOfMacroExpansion</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#099400063BE4160E2C380CAA0EEF38F1A1A35039">makeFileCharRange</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#7EAAFF561CCA389BC38365D460114679E343162B">getSourceText</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#B9B240CE1EB62455FDBC076BD40A4A91B285B2F9">getImmediateMacroName</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#EACFF37D2D6B1D3F65DAD7A946BB5812C9D0039D">getImmediateMacroNameForDiagnostics</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#9977FC43D5174F76E6220476DA477BB591CE04CA">ComputePreamble</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#A36AAF92A0D407E3DBCA3136A47675D35580E820">findNextToken</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#B1528AB7EA001D3F5E830D3268F90BA6F2714DFB">findLocationAfterToken</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#70F988EB3DD6B9B723E6ADF96B46F0C64DCDFC08">isAsciiIdentifierContinueChar</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#CEF30CF850A1591589FA5028F13C02A2270833E2">isNewLineEscaped</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#88E226BE5692DF200287C06032B4BE5BC613F76F">getCharAndSizeNoWarn</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#7AAEE959A1B59428FEE2CA7B5D60EE4661673CBB">getIndentationForLine</a>
            </span>
          </li>
          <li>
            <span>
              <a href="#010DAC6219F8CFEA580D4FF025D08CE850155057">isFirstTimeLexingFile</a>
            </span>
          </li>
        </ul>
      </li>
    </ol>
  </div>
</main>
<footer>
  <span class="no-break">Ubuntu clang-doc version 16.0.0 (++20230103042323+3bbdd9f506c1-1~exp1~20230103042429.660)</span>
</footer>
