<!DOCTYPE html>
<meta charset="utf-8"/>
<title>class MockFunction</title>
<link rel="stylesheet" href="../clang-doc-default-stylesheet.css"/>
<script src="../index.js"></script>
<script src="../index_json.js"></script>
<header id="project-title">Subspace</header>
<main>
  <div id="sidebar-left" path="testing" class="col-xs-6 col-sm-3 col-md-2 sidebar sidebar-offcanvas-left"></div>
  <div id="main-content" class="col-xs-12 col-sm-9 col-md-8 main-content">
    <h1>class MockFunction</h1>
    <p>
      Defined at line 
      <a href="https://github.com/chromium/subspace/blob/main/third_party/googletest/googlemock/include/gmock/gmock-spec-builders.h#1996">1996</a>
       of file 
      <a href="https://github.com/chromium/subspace/blob/main/third_party/googletest/googlemock/include/gmock/gmock-spec-builders.h">gmock-spec-builders.h</a>
    </p>
    <div>
      <div>
        <p> A MockFunction&lt;F&gt; type has one mock method whose type is internal::SignatureOfT&lt;F&gt;.  It is useful when you just want your test code to emit some messages and have Google Mock verify the right messages are sent (and perhaps at the right times).  For example, if you are exercising code:</p>
        <p>   Foo(1);   Foo(2);   Foo(3);</p>
        <p> and want to verify that Foo(1) and Foo(3) both invoke mock.Bar(&quot;a&quot;), but Foo(2) doesn&apos;t invoke anything, you can write:</p>
        <p> TEST(FooTest, InvokesBarCorrectly) {   MyMock mock;   MockFunction&lt;void(string check_point_name)&gt; check;   {     InSequence s;</p>
        <p>     EXPECT_CALL(mock, Bar(&quot;a&quot;));     EXPECT_CALL(check, Call(&quot;1&quot;));     EXPECT_CALL(check, Call(&quot;2&quot;));     EXPECT_CALL(mock, Bar(&quot;a&quot;));   }   Foo(1);   check.Call(&quot;1&quot;);   Foo(2);   check.Call(&quot;2&quot;);   Foo(3); }</p>
        <p> The expectation spec says that the first Bar(&quot;a&quot;) must happen before check point &quot;1&quot;, the second Bar(&quot;a&quot;) must happen after check point &quot;2&quot;, and nothing should happen between the two check points. The explicit check points make it easy to tell which Bar(&quot;a&quot;) is called by which call to Foo().</p>
        <p> MockFunction&lt;F&gt; can also be used to exercise code that accepts std::function&lt;internal::SignatureOfT&lt;F&gt;&gt; callbacks. To do so, use AsStdFunction() method to create std::function proxy forwarding to original object&apos;s Call. Example:</p>
        <p> TEST(FooTest, RunsCallbackWithBarArgument) {   MockFunction&lt;int(string)&gt; callback;   EXPECT_CALL(callback, Call(&quot;bar&quot;)).WillOnce(Return(1));   Foo(callback.AsStdFunction()); }</p>
        <p> The internal::SignatureOfT&lt;F&gt; indirection allows to use other types than just function signature type. This is typically useful when providing a mock for a predefined std::function type. Example:</p>
        <p> using FilterPredicate = std::function&lt;bool(string)&gt;; void MyFilterAlgorithm(FilterPredicate predicate);</p>
        <p> TEST(FooTest, FilterPredicateAlwaysAccepts) {   MockFunction&lt;FilterPredicate&gt; predicateMock;   EXPECT_CALL(predicateMock, Call(_)).WillRepeatedly(Return(true));   MyFilterAlgorithm(predicateMock.AsStdFunction()); }</p>
      </div>
    </div>
    <p>Inherits from internal::MockFunction&lt;internal::SignatureOfT&lt;F&gt; &gt;</p>
  </div>
  <div id="sidebar-right" class="col-xs-6 col-sm-6 col-md-2 sidebar sidebar-offcanvas-right"></div>
</main>
<footer>
  <span class="no-break">Ubuntu clang-doc version 16.0.0 (++20230125042347+9b70a28e0d76-1~exp1~20230125042505.706)</span>
</footer>
